#include <assert.h>
#include "cbs_target.h"
#include "cbs_scsi.h"

/**
 * Sense Context Table. Sense codes are SCSI error codes and a sense
 * context is shorthand for an error that occurs in the RAID. The SCSI Sense
 * codes are generated by a simple lookup of a sense context. This is
 * easier than generating SCSI sense codes because many similar operations
 * generate the same codes. If we want to change this behaviour we have to 
 * change the code in one place - here.
 */
typedef struct sense_tuple
{
    uint8 key;
    uint16 asc;
}sense_tuple_t;

static sense_tuple_t sense_ctx_tbl[nb_sense_contexts] = {
    /** SENSE_CTX_NONE             */{ KEY_NO_SENSE, ASC_NO_ADDT_SENSE_INFO         },
    /** SENSE_CTX_TASK_FULL        */{ KEY_NO_SENSE, ASC_NO_ADDT_SENSE_INFO },
    /** SENSE_CTX_ILLEGAL_CDB      */{ KEY_ILLEGAL_REQUEST, ASC_INVALID_FIELD_IN_CDB },
    /** SENSE_CTX_NOT_READY        */{ KEY_NOT_READY, ASC_LUN_NR_BECOMING_RDY },
    /** SENSE_CTX_HARDWARE_ERR     */{ KEY_HARDWARE_ERROR, ASC_INTERNAL_TARGET_ERR },
    /** SENSE_CTX_WRITE_PROTECT    */{ KEY_DATA_PROTECT, ASC_WR_PROTECTED },
    /** SENSE_CTX_LUN_UNSUPPORTED  */{ KEY_ILLEGAL_REQUEST, ASC_LUN_UNSUPPORTED },
    /** SENSE_CTX_RESERVE_CONF     */{ KEY_NO_SENSE, ASC_NO_ADDT_SENSE_INFO },
    /** SENSE_CTX_RESET_POWER_ON   */{ KEY_UNIT_ATTENTION, ASC_POWER_ON_RESET },
    /** SENSE_CTX_RESET_DIRECTED   */{ KEY_UNIT_ATTENTION, ASC_BUS_DEVICE_RESET },
    /** SENSE_CTX_MEDIUM_ERR_RD    */{ KEY_MEDIUM_ERROR, ASC_RD_ERR },
    /** SENSE_CTX_MEDIUM_ERR_WR    */{ KEY_MEDIUM_ERROR, ASC_WR_ERR },
    /** SENSE_CTX_MEDIUM_ERR_AMNF  */{ KEY_MEDIUM_ERROR, ASC_ADDR_MARK_NOT_FOUND },
    /** SENSE_CTX_TASK_SET_CLEARED */{ KEY_UNIT_ATTENTION, ASC_TAG_CMD_CLRD_BY_OTHER_INIT },
    /** SENSE_CTX_VOL_OVERFLOW     */{ KEY_VOLUME_OVERFLOW, ASC_LOGICAL_BLOCK_OUT_OF_RANGE },
    /** SENSE_CTX_FC_ERR           */{ KEY_ABORTED_COMMAND, ASC_SCSI_BUS_PARITY_ERR },
    /** SENSE_CTX_SCSI_PARITY_ERR  */{ KEY_ABORTED_COMMAND, ASC_SCSI_BUS_PARITY_ERR },
    /** SENSE_CTX_SCSI_DATA_ERR    */{ KEY_ABORTED_COMMAND, ASC_SCSI_DATA_PHASE_CRC_ERR },
    /** SENSE_CTX_SCSI_ST_ERR      */{ KEY_ABORTED_COMMAND, ASC_SCSI_ST_DATA_PHASE_CRC_ERR },
    /** SENSE_CTX_SCSI_IU_ERR      */{ KEY_ABORTED_COMMAND, ASC_SCSI_IU_PHASE_CRC_ERR },
    /** SENSE_CTX_MSG_RJT_ERR      */{ KEY_ABORTED_COMMAND, ASC_MSG_RJT_ERR },
    /** SENSE_CTX_INITIATOR_ERR    */{ KEY_ABORTED_COMMAND, ASC_INITIATOR_DETECTED_ERR },
    /** SENSE_CTX_RESERVES_PREEMPTED*/{ KEY_UNIT_ATTENTION, ASC_RESERVATIONS_PREEMPTED },
    /** SENSE_CTX_DOWNLOAD_FAILED   */{ KEY_HARDWARE_ERROR, ASC_CHECKSUM_ERROR_ON_DOWNLOAD },
    /** SENSE_CTX_INSUFF_REG_RESOURC*/{ KEY_ILLEGAL_REQUEST, ASC_INSUFFICIENT_REGISTRATION_RESOURCES },
    /** SENSE_CTX_PARAM_LIST_LEN_ERR*/{ KEY_ILLEGAL_REQUEST, ASC_PARAM_LIST_LEN_ERR },
    /** SENSE_CTX_INVALID REL _OF_PR*/{ KEY_ILLEGAL_REQUEST, ASC_INVALD_RELEASE_OF_PR },
    /** SENSE_CTX_IFP_IN_PARAM_LIST */{ KEY_ILLEGAL_REQUEST, ASC_IFP_IN_PARAM_LIST },
    /** SENSE_CTX_TP_IN_TRANSIT   */{ KEY_NOT_READY, ASC_LUN_NA_TP_IN_TRANSIT },
    /** SENSE_CTX_TP_IN_STANDY      */{ KEY_NOT_READY, ASC_LUN_NA_TP_IN_STANDBY },
    /**SENSE_CTX_TP_IN_UNAVAILABLE  */{ KEY_NOT_READY, ASC_LUN_NA_TP_IN_UNAVAILABLE },

    /** SENSE_CTX_INTERNAL_REBUILD_FAILED */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_REBUILD_STRIPE_FAILED },
    /** SENSE_CTX_INTERNAL_CMD_FAILED     */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_CMD_FAILED },
    /** SENSE_CTX_INTERNAL_XFER_FAILED    */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_XFER_FAILED },
    /** SENSE_CTX_INTERNAL_RESOURCE_FAILED*/{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_RESOURCE_FAILED },
    /** SENSE_CTX_INTERNAL_WRONG_PARAM    */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_WRONG_PARAM },
    /** SENSE_CTX_INTERNAL_LINK_DOWN      */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_LINK_DOWN },
    /** SENSE_CTX_INTERNAL_DEVICE_GONE    */{ KEY_ABORTED_COMMAND, ASC_RT_INTERNAL_DEVICE_GONE }
};

typedef struct scsi_inquiry_vpd_unit_serial {
    uint8 type;
    uint8 page;   /* 0x80 */
    uint8 rsvd;    /* 0x0 */
    uint8 length;  /* 0x8 */
    uint8 serial[20];
}scsi_inquiry_vpd_unit_serial_t;

typedef struct scsi_inquiry_vpd_wwn {
    uint8 type;
    uint8 page;    /* 0x83 */
    uint8 rsvd;    /* 0x00 */
    uint8 length;  /* 0x0c */
    uint8 code_set;
    uint8 assoc_idtype;
    uint8 reserved;
    uint8 id_len; /* 0x08 */
    uint8 id[8];
}scsi_inquiry_vpd_wwn_t;

typedef struct scsi_inquiry_firmware {
    uint8 type;
    uint8 page;    /* 0xC0 */
    uint8 rsvd;    /* 0x00 */
    uint8 length;  /* 0x08 */
    uint8 release_num[8];
}scsi_inquiry_firmware_t;

typedef struct scsi_inquiry_info {
    uint8 type;                     //0
    uint8 modifier;                 //1
    uint8 version;                  //2
    uint8 rdf;                      //3
    uint8 length;                   //4
    uint8 rsvd;                     //5
    uint8 port_info;                //6
    uint8 bits;                     //7
    uint8 vendor_id[8];             //8
    uint8 prod_id[16];              //16
    uint8 rev_id[4];                //32
    uint8 serial[20];               //36
    uint8 clocking;                 //56
    uint8 rsvd1;                    //57
    uint8 version_descs[16];        //58
    uint8 resvd2[21];               //74
    uint8 vendor_spec[4];           //95
    uint8 resvd3;                   // 99
}scsi_inquiry_info_t;

typedef struct scsi_inquiry_vpd_list {
    uint8 type;
    uint8 page;   /* 0x80 */
    uint8 rsvd;    /* 0x0 */
    uint8 length;  /* 0x8 */
    uint8 supported_pages[16];
}scsi_inquiry_vpd_list_t;

typedef struct scsi_mode_page2 {
    uint8 page;                 /* 0x82 */
    uint8 len;                  /* 0x0e */
    uint8 buffer_full;          /* 0x80 */
    uint8 buffer_empty;         /* 0x80 */
    uint8 buffer_inact_msb;     /* 0x00 */
    uint8 buffer_inact_lsb;     /* 0x0a */
    uint16 disconn_time_limit;  /* 0x0000 */
    uint16 conn_time_limit;     /* 0x0000 */
    uint16 max_burst_size;      /* 0x0000 */
    uint8 diss_bits;            /* 0x0 */
    uint8 reserved1;            /* 0x0 */
    uint16 first_burst_size;     /* 0x0 */
}scsi_mode_page2_t;

/**
 * Format Parameters Mode Page
 */

typedef struct scsi_mode_page3{
    uint8 page;                 /* 0x83 */
    uint8 len;                  /* 0x16 */
    uint16 tracks_per_zone;     /* 0x0015 */
    uint16 alt_sect_per_zone;   /* 0x0009 */
    uint16 alt_trks_per_zone;   /* 0x0000 */
    uint16 alt_trks_per_vol;    /* 0x0015 */
    uint16 sectors_per_track;   /* 0x0080 */
    uint16 bytes_per_sector;    /* 0x0200 */
    uint16 interleave;          /* 0x0001 */
    uint16 track_skew;          /* 0x0009 */
    uint16 cylinder_skew;       /* 0x0010 */
    uint8 bits;                 /* 0x04 */
    uint8 reserved1;            /* 0x0 */
    uint8 reserved2;            /* 0x0 */
    uint8 reserved3;            /* 0x0 */
}scsi_mode_page3_t;

/**
 * Disk Geometry Mode page
 */
typedef struct scsi_mode_page4{
    uint8 page;                 /* 0x84 */
    uint8 len;                  /* 0x16 */
    uint8 num_cylinders_msb;    /* 0x00 */
    uint8 num_cylinders;        /* 0x0e */
    uint8 num_cylinders_lsb;    /* 0x80 */
    uint8 num_heads;            /* 0x20 */
    uint8 start_cyl_wrt_pre0;   /* 0x00 */
    uint8 start_cyl_wrt_pre1;   /* 0x00 */
    uint8 start_cyl_wrt_pre2;   /* 0x00 */
    uint8 start_cyl_red_wrt0;   /* 0x00 */
    uint8 start_cyl_red_wrt1;   /* 0x00 */
    uint8 start_cyl_red_wrt2;   /* 0x00 */
    uint8 drive_step_rate0;     /* 0x0000 */
    uint8 drive_step_rate1;     /* 0x0000 */
    uint8 landing_zone0;        /* 0x0000 */
    uint8 landing_zone1;        /* 0x0000 */
    uint8 landing_zone2;        /* 0x0000 */
    uint8 rpl;                  /* 0x00 */
    uint8 rotational_offset;    /* 0x00 */
    uint8 reserved1;            /* 0x00 */
    uint16 medium_rot_rate;     /* 0x1c20 */
    uint8 reserved2;            /* 0x0 */
    uint8 reserved3;            /* 0x0 */
}scsi_mode_page4_t;

/**
 * Caching Parameters Page
 */
typedef struct scsi_mode_page8{
    uint8 page;                 /* 0x84 */
    uint8 len;                  /* 0x12 */
    uint8 bits;                 /* 0x14 */
    uint8 retention_prio;       /* 0x00 */
    uint16 dis_pref_xfer_len;   /* 0xffff */
    uint16 minimum_prefetch;    /* 0x0000 */
    uint16 max_prefetch;        /* 0x009f */
    uint16 max_pref_ceiling;    /* 0x027c */
    uint8 fsw_lbcss_dra;        /* 0x80 */
    uint8 num_cache_segs;       /* 0x03 */
    uint16 cache_seg_size;      /* 0x0000 */
    uint8 reserved;             /* 0x00 */
    uint8 non_cache_seg0;       /* 0x00 */
    uint8 non_cache_seg1;       /* 0x00 */
    uint8 non_cache_seg2;       /* 0x00 */
}scsi_mode_page8_t;

/**
 * Mode Sense/Select Control Page
 */
typedef struct scsi_mode_pageA{
    uint8 page;                 /* 0x8a */
    uint8 len;                  /* 0x0a */
    uint8 bits;                 /* 0x02 */
    uint8 queue_bits;           /* 0x10 */
    uint8 rac_swp;              /* 0x00 */
    uint8 autoload_mode;            /* 0x00 */ //changed from reserved to auto
    uint16 unsupp;              /* 0x0000 */
    uint16 busy_timeout;        /* 0x0000 */
    uint16 st_completion_time;   /* 0x00 */   //changed from reserved to..
}scsi_mode_pageA_t;

/**
 * Informational Exceptions Page
 */
typedef struct scsi_mode_page1C{
    uint8 page;                 /* 0x9c */
    uint8 len;                  /* 0x0a */
    uint8 bits;                 /* 0x00 */
    uint8 mrie;                 /* 0x00 */
    uint32 interval_timer;      /* 0x00000000 */
    uint32 report_count;        /* 0x00000000 */
}scsi_mode_page1C_t;

static CTargetPool g_target_pool;

CTarget* get_target_by_class_id(uint32 class_id)
{
    return g_target_pool.get_target_by_class_id(class_id);
}

CTarget* get_target_by_device_no(uint32 device_no)
{
    CDevice *p_dev = get_device_by_index(device_no);
    return get_target_by_class_id(p_dev->get_class_id());
}

void target_ReplyGood(cbs_buf_t *p_cbuf)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_good(p_cbuf);
}

void target_ReplyNoDevice(cbs_buf_t *p_cbuf)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_nodevice(p_cbuf);
}

void target_ReplyCmdAborted(cbs_buf_t *p_cbuf)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_cmd_aborted(p_cbuf);
}

void target_ReplyCmdDoneWithError(cbs_buf_t *p_cbuf, uint32 sense)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_cmd_with_error(p_cbuf, sense);
}

void target_ReplyComplete(cbs_buf_t *p_cbuf)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_complete(p_cbuf);
}

void target_ReplyError(cbs_buf_t *p_cbuf)
{
    get_target_by_device_no(p_cbuf->device_no)->reply_error(p_cbuf);
}

uint32 target_LoadInquiryPage(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    return get_target_by_device_no(p_cbuf->device_no)->load_inquiry_page(p_cbuf, p_buf, nbytes);
}

uint32 target_LoadModePage(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    return get_target_by_device_no(p_cbuf->device_no)->load_mode_page(p_cbuf, p_buf, nbytes);
}

void target_QueueCbuf(CDevice *p_dev,  cbs_buf_t *p_cbuf)
{
    CTarget *p_target = get_target_by_class_id(p_dev->get_class_id());
    p_target->queue_cbuf(p_dev, p_cbuf);
}

void target_DeviceScan(CDevice *p_dev)
{
    CTarget *p_target = get_target_by_class_id(p_dev->get_class_id());

    /** scan the timer queue of the device */
    p_dev->check_expire();
    /** scan the device */
    p_target->device_scan(p_dev);
}


/*-----------------------------------------class target-------------------------------------------------------------------*/
void CTarget::translate_sense_ctx(uint32 sense_ctx, scsi_sense_info_t *p_sense_info)
{
    uint16 add_code_qual;

    add_code_qual = sense_ctx_tbl[sense_ctx].asc;
    p_sense_info->key     = sense_ctx_tbl[sense_ctx].key;
    p_sense_info->rsv1    = 0;
    p_sense_info->ili     = 0;
    p_sense_info->rsv2    = 0;
    p_sense_info->segment = 0;
    p_sense_info->error_code  = 0x70;
    p_sense_info->valid   = 0;
    p_sense_info->addt_len = 0xa;             /* should be set to 0xa maximum. */
    p_sense_info->info[0] = 0;
    p_sense_info->info[1] = 0;
    p_sense_info->info[2] = 0;
    p_sense_info->info[3] = 0;
    p_sense_info->csi     = 0;
    p_sense_info->sks0    = 0;
    p_sense_info->sksv    = 0;
    p_sense_info->rsv3    = 0;
    p_sense_info->addt_sc_qualifier = (add_code_qual) & 0xff;
    p_sense_info->addt_sc           = (add_code_qual >> 8) & 0xff;
    p_sense_info->uniq_sense_data0  = 0;
    p_sense_info->uniq_sense_data1  = 0;
    p_sense_info->sks2              = 0;
    p_sense_info->sks1              = 0;

    return;
}

void CTarget::get_sense_info_and_update(cbs_buf_t *p_cbuf)
{
    if (p_cbuf->target.gen.sense_context > nb_sense_contexts)
    {
        LOG_ERROR("invalid sense context:0x%x", p_cbuf->target.gen.sense_context);
        p_cbuf->target.gen.sense_context = SENSE_CTX_NONE;
    }
    translate_sense_ctx(p_cbuf->target.gen.sense_context, get_device_sense(p_cbuf->device_no));

    return;
}

scsi_sense_info_t* CTarget::get_device_sense(uint32 device_no)
{
    CDevice *p_dev = get_device_by_index(device_no);
    return &p_dev->_latest_sense;
}

/*
 *Function Name:build_check_resp_info
 *
 *Parameters:cbs_buf_t
 *
 *Description:Builds the response information field of the cbuf 
 *            if scsi status is not good. 
 *
 *Returns:void
 *
 */
void CTarget::build_check_resp_info(cbs_buf_t *p_cbuf)
{
    scsi_sense_info_t *p_sense_info;

    /* If the context is already valid, we don't want to overwrite it */
    if (p_cbuf->packet.response.status_flags & CBUF_STATUS_FLAG_SENSE_LEN_VALID)
    {
        return;
    }

    p_cbuf->packet.response.status_flags = CBUF_STATUS_FLAG_SENSE_LEN_VALID | CBUF_STATUS_FLAG_RSP_LEN_VALID;
    p_cbuf->packet.response.residual_count = 0;

    p_cbuf->packet.response.resp_info_len = 8;

    get_sense_info_and_update(p_cbuf);
    p_sense_info = &p_cbuf->packet.response.sense_info;
    p_cbuf->packet.response.sense_data_len = target_extract_sense_info(*p_sense_info, p_cbuf->device_no);

    if (p_cbuf->packet.response.sense_info.key == KEY_NO_SENSE)
    {
        p_cbuf->packet.response.status_flags &= ~CBUF_STATUS_FLAG_SENSE_LEN_VALID;
        p_cbuf->packet.response.sense_data_len = 0;
    }

    return;
}

/****************************** load inquiry pages *********************************/
uint32 CTarget::load_unit_serial_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    uint32 copy_size;
    scsi_inquiry_vpd_unit_serial_t *p_inq;
    scsi_inquiry_vpd_unit_serial_t local_inquiry;
    CDevice *p_dev;

    p_dev = get_device_by_index(p_cbuf->device_no);
    p_inq = &local_inquiry;

    p_inq->type = 0;
    p_inq->page = 0x80;
    p_inq->rsvd = 0;
    p_inq->length = 0x12;

    copy_size = MIN(nbytes, sizeof(scsi_inquiry_vpd_unit_serial_t));
    rtu_MemCopy(p_buf, (uint8 *)&local_inquiry, copy_size);

    return copy_size;
}

uint32 CTarget::load_wwn_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    uint32 copy_size;
    scsi_inquiry_vpd_wwn_t *p_inq;
    scsi_inquiry_vpd_wwn_t local_inquiry;
    unique_id_t unique;
    p_inq = &local_inquiry;

    p_inq->type = 0;
    p_inq->page = 0x83;
    p_inq->rsvd = 0;
    p_inq->length = 0xc;
    p_inq->code_set = 0x01;
    p_inq->assoc_idtype = 0x13;
    p_inq->reserved = 0x00;
    p_inq->id_len = 0x08;
    p_inq->id[0] = unique.bytes[0];
    p_inq->id[1] = unique.bytes[1];
    p_inq->id[2] = unique.bytes[2];
    p_inq->id[3] = unique.bytes[3];
    p_inq->id[4] = unique.bytes[4];
    p_inq->id[5] = unique.bytes[5];
    p_inq->id[6] = unique.bytes[6];
    p_inq->id[7] = unique.bytes[7];
    copy_size = MIN(nbytes, sizeof(scsi_inquiry_vpd_wwn_t));
    rtu_MemCopy(p_buf, (uint8 *)&local_inquiry, copy_size);

    return copy_size;
}

uint32 CTarget::_load_Firmware_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    uint32 copy_size;
    scsi_inquiry_firmware_t *p_inq;
    scsi_inquiry_firmware_t local_inquiry;
    uint32  version = 0; /* Fix Me. */ //ver_GetFirmwareRevision();

    p_inq = &local_inquiry;

    p_inq->type = 0;
    p_inq->page = 0xC0;
    p_inq->rsvd = 0;
    p_inq->length = 0x8;
    p_inq->release_num[0] = '0';
    p_inq->release_num[1] = '0';
    p_inq->release_num[2] = '0';
    p_inq->release_num[3] = '0';
    p_inq->release_num[4] = (version & 0xff000000) >> 24;
    p_inq->release_num[5] = (version & 0x00ff0000) >> 16;
    p_inq->release_num[6] = (version & 0x0000ff00) >> 8;
    p_inq->release_num[7] = (version & 0x000000ff);

    copy_size = MIN(nbytes, sizeof(scsi_inquiry_firmware_t));
    rtu_MemCopy(p_buf, (uint8 *)&local_inquiry, copy_size);

    return copy_size;
}

uint32 CTarget::_load_zero_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    return 0;
}

uint32 CTarget::_load_stand_inquiry_page(CDevice *p_dev, cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    scsi_inquiry_info_t *p_inq;
    scsi_inquiry_info_t local_inquiry;
    uint32 copy_size;

    p_inq = &local_inquiry;
    p_inq->type = 0;
    p_inq->modifier = 0;
    p_inq->version = 0x5;
    p_inq->rdf = 0x02; /* NACA unsupported */
    p_inq->length = sizeof(scsi_inquiry_info_t) - 4;
    p_inq->rsvd = 0;

    p_inq->bits = 0x32; /* wide data (16bit) | SYNC Transfer | Tagged Command Queueing enable */
    p_inq->clocking = 0x0f; /* ST&DT | QAS | IUS */

    p_inq->version_descs[1] =   0x03;
    p_inq->version_descs[0] =   0x01;


    strncpy((char *)&p_inq->prod_id, "TARGET UNKNOWN  ", 16);
    strncpy((char *)&p_inq->rev_id, "0000", 4);
    strncpy((char *)&p_inq->serial, "12345678", 8);

    /* call target specific funciton here */
    load_stand_inquiry_page(p_dev, p_cbuf, p_buf, nbytes);

    copy_size = MIN(nbytes, sizeof(scsi_inquiry_info_t));
    rtu_MemCopy(p_buf, (uint8 *)&local_inquiry, copy_size);

    return copy_size;
}

uint32 CTarget::load_stand_inquiry_page(CDevice *p_dev, cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    return 0;
}

/*
 *Function Name:load_inquiry_page
 *
 *Parameters:
 *
 *Description:load inquiry page when we recieved a inquiry CDB.
 *
 *Returns:return the length of the page that we supported,return SCSI_UNSUPPORTED_INQUIRY_PAGE_LEN if the page we unsupported
 *
 */
uint32 CTarget::load_inquiry_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    uint32 copy_size;
    uint32 i;
    uint8  page_num;
    uint8 *p_cdb = &(p_cbuf->packet.cmd.cdb[0]);

    if (!(p_cdb[1] & 0x1))
    {
        CDevice *p_dev = get_device_by_index(p_cbuf->device_no);
        copy_size = _load_stand_inquiry_page(p_dev, p_cbuf, p_buf, nbytes);
    } else
    {
        page_num = p_cdb[2];
        copy_size = 0;

        if (page_num == 0)
        {
            /* list of supported pages */
            scsi_inquiry_vpd_list_t *p_inq;
            scsi_inquiry_vpd_list_t local_inquiry;
            p_inq =  &local_inquiry;
            p_inq->type = 0;
            p_inq->page = 0;
            p_inq->rsvd = 0;
            p_inq->length = 0;
            std::map<int, load_inq_func>::iterator mit = _inq_pages.begin();
            for (i = 0; mit != _inq_pages.end(); mit++, i++)
            {
                p_inq->supported_pages[i] = mit->first;
                p_inq->length++;
            }

            copy_size = p_inq->length + 4;
            copy_size = MIN(copy_size, nbytes);
            rtu_MemCopy(p_buf, (uint8 *)&local_inquiry, copy_size);
        } else
        {
            copy_size = SCSI_UNSUPPORTED_INQUIRY_PAGE_LEN;
            std::map<int, load_inq_func>::iterator mit = _inq_pages.find(page_num);
            if (mit != _inq_pages.end())
            {
                copy_size = (this->*_inq_pages[page_num])(p_cbuf, p_buf, nbytes);
            }
        }
    }

    return copy_size;
}
/************************************* end of loadding inquiry pages **************************/

/************************************* load mode pages **************************************/
uint32 CTarget::load_mode_page(cbs_buf_t *p_cbuf, uint8 *p_buf, uint32 nbytes)
{
    uint32 page_len;
    uint32 copy_len;
    uint32 total_len;
    uint32 alloc_len;
    uint32 i;
    uint8 page_num;
    uint8 subpage_num;
    uint8 *p;
    uint8 *p_cdb;

    p_cdb = &(p_cbuf->packet.cmd.cdb[0]);

    page_num = p_cdb[2] & 0x3f;
    subpage_num = p_cdb[3];
    p = p_buf;
    total_len = 0;

    if (p_cdb[0] == SCMD_MODE_SENSE)
    {
        alloc_len = p_cdb[4];
        total_len = 4;
        for (i = 0; i < 4; i++)
        {
            p[i] = 0;
        }
        if ((p_cdb[1] & 0x08) == 0) // disable block descriptors
        {
            p[3] = 8; /* block descriptor_length */
        }
        p += 4;
    } else
    {
        alloc_len = p_cdb[7];
        alloc_len <<= 8;
        alloc_len += p_cdb[8];

        assert(p_cdb[0] == SCMD_MODE_SENSE_10);
        total_len = 8;
        for (i = 0; i < 8; i++)
        {
            p[i] = 0;
        }
        if ((p_cdb[1] & 0x08) == 0) // disable block descriptors
        {
            p[7] = 8; /* block descriptor_length */
        }
        p += 8;
    }
    if ((p_cdb[1] & 0x08) == 0) // disable block descriptors
    {
        /* block descriptor */
        for (i = 0; i < 8; i++)
        {
            p[i] = 0;
        }
        p[6] = 2; /* block size  = 512  = 0x200 */

        p += 8;
        total_len += 8;
    }

    if (page_num == 0x3f)
    {
        /* return all pages */
        std::map<int, std::map<int, load_mod_func> >::iterator mit_1 = _mod_pages.begin();
        for (; mit_1 != _mod_pages.end(); mit_1++)
        {
            std::map<int, load_mod_func>::iterator mit_2 = mit_1->second.begin();
            for (; mit_2 != mit_1->second.end(); mit_2++)
            {
                //page_num = 0x3f && subpage_num =0, just return the page,so ,we skip the subpage here.
                if ((subpage_num == 0) && (mit_2->first != 0))
                {
                    continue;
                }

                //if subpage_num =0, we just load page; if subpage_num !=0, we load all pages;
                copy_len = (this->*mit_2->second)(p_cbuf, p, alloc_len);
                page_len = p[1] + 2; //include Page Code and Page Length
                alloc_len -= copy_len;
                p += copy_len;

                total_len += page_len;
            }
        }
    } else // load individual page
    {
        if (subpage_num != 0xFF)
        {
            /* return individual pages */
            std::map<int, std::map<int, load_mod_func> >::iterator mit_1 = _mod_pages.begin();
            for (; mit_1 != _mod_pages.end(); mit_1++)
            {
                if (mit_1->first == page_num)
                {
                    std::map<int, load_mod_func>::iterator mit_2 = mit_1->second.begin();
                    for (; mit_2 != mit_1->second.end(); mit_2++)
                    {
                        if (mit_2->first == subpage_num)
                        {

                            //if subpage_num =0, we just load page; if subpage_num !=0, we load all pages;
                            copy_len = (this->*mit_2->second)(p_cbuf, p, alloc_len);
                            page_len = p[1] + 2; //include Page Code and Page Length
                            alloc_len -= copy_len;
                            p += copy_len;

                            total_len += page_len;
                        }
                    }
                }
            }
        } else
        {
            /* return individual pages with all subpage*/
            std::map<int, std::map<int, load_mod_func> >::iterator mit_1 = _mod_pages.find(page_num);
            if (mit_1 != _mod_pages.end())
            {
                std::map<int, load_mod_func>::iterator mit_2 = mit_1->second.begin();
                for (; mit_2 != mit_1->second.end(); mit_2++)
                {
                    copy_len = (this->*mit_2->second)(p_cbuf, p, alloc_len);
                    page_len = p[1] + 2; //include Page Code and Page Length
                    alloc_len -= copy_len;
                    p += copy_len;

                    total_len += page_len;
                }
            }
        }
    }

    /*
     * fill in length field
     */

    if (p_cdb[0] == SCMD_MODE_SENSE)
    {
        page_len = total_len - 1; // dont include Mode sense data length itself
        p_buf[0] = page_len & 0xff;
    } else /* SCMD_MODE_SENSE_10 */
    {
        page_len = total_len - 2;
        p_buf[0] = (page_len & 0xff00) >> 8;
        p_buf[1] = page_len & 0xff;
    }

    return total_len;
}

uint32 CTarget::load_disconnect_reconnect_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_page2_t *p_mode;
    scsi_mode_page2_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8 *)&local_page, sizeof(scsi_mode_page2));

    p_mode->page = 0x02;
    p_mode->len = 0x0e;
    if ((p_cdb[2] & 0xc0) != 0x40)
    {
        p_mode->buffer_full = 0x80;
        p_mode->buffer_empty = 0x80;
        p_mode->buffer_inact_msb = 0x00;
        p_mode->buffer_inact_lsb =  0x0a;
        p_mode->disconn_time_limit = 0x0000;
        p_mode->conn_time_limit = 0x0000;
        p_mode->max_burst_size = 0x0000;
        p_mode->diss_bits = 0; // 0x0b;   // DTDC = 011
        p_mode->reserved1 = 0x0;
        p_mode->first_burst_size = 0x0;
    }

    copy_size = MIN(n_bytes, sizeof(scsi_mode_page2_t));
    rtu_MemCopy(p_buf, (uint8 *)&local_page, sizeof(scsi_mode_page2_t)); //copy whole page anyway

    return copy_size;
}

/**
 * Format Parameters Mode Page
 */
uint32 CTarget::load_format_parameters_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_page3_t *p_mode;
    scsi_mode_page3_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8*)&local_page, sizeof(scsi_mode_page3_t));

    p_mode->page = 0x03;
    p_mode->len = 0x16;
    if((p_cdb[2] & 0xc0) != 0x40){
        p_mode->tracks_per_zone = 0x0015;
        p_mode->alt_sect_per_zone = 0x0009;
        p_mode->alt_trks_per_zone = 0x0000;
        p_mode->alt_trks_per_vol = 0x0015;
        p_mode->sectors_per_track = 0x0080;
        p_mode->bytes_per_sector = 0x0200;
        p_mode->interleave = 0x0001;
        p_mode->track_skew = 0x0009;
        p_mode->cylinder_skew = 0x0010;
        p_mode->bits = 0x04;
        p_mode->reserved1 = 0x0;
        p_mode->reserved2 = 0x0;
        p_mode->reserved3 = 0x0;
    }
    
    copy_size = MIN(n_bytes, sizeof(scsi_mode_page3_t));
    rtu_MemCopy(p_buf, (uint8*)&local_page, sizeof(scsi_mode_page3_t));

    return copy_size;
}

uint32 CTarget::load_disk_geometry_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_page4_t *p_mode;
    scsi_mode_page4_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8*)&local_page, sizeof(scsi_mode_page4_t));

    p_mode->page = 0x04;
    p_mode->len = 0x16;
    if((p_cdb[2] & 0xc0) != 0x40){
        p_mode->page = 0x84;
        p_mode->len = 0x16;
        p_mode->num_cylinders_msb = 0x00;
        p_mode->num_cylinders = 0x0e;
        p_mode->num_cylinders_lsb = 0x80;
        p_mode->num_heads = 0x20;
        p_mode->start_cyl_wrt_pre0 = 0x00;
        p_mode->start_cyl_wrt_pre1 = 0x00;
        p_mode->start_cyl_wrt_pre2 = 0x00;
        p_mode->start_cyl_red_wrt0 = 0x00;
        p_mode->start_cyl_red_wrt1 = 0x00;
        p_mode->start_cyl_red_wrt2 = 0x00;
        p_mode->drive_step_rate0 = 0x0000;
        p_mode->drive_step_rate1 = 0x0000;
        p_mode->landing_zone0 = 0x0000;
        p_mode->landing_zone1 = 0x0000;
        p_mode->landing_zone2 = 0x0000;
        p_mode->rpl = 0x00;
        p_mode->rotational_offset = 0x00;
        p_mode->reserved1 = 0x00;
        p_mode->medium_rot_rate = 0x1c20;
        p_mode->reserved2 = 0x0;
        p_mode->reserved3 = 0x0;
    }
    
    copy_size = MIN(n_bytes, sizeof(scsi_mode_page4_t));
    rtu_MemCopy(p_buf, (uint8*)&local_page, sizeof(scsi_mode_page4_t));

    return copy_size;
}

uint32 CTarget::load_cacheing_parameters_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_page8_t *p_mode;
    scsi_mode_page8_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8*)&local_page, sizeof(scsi_mode_page8_t));

    p_mode->page = 0x08;
    p_mode->len = 0x12;
    if((p_cdb[2] & 0xc0) != 0x40){
        p_mode->bits = 0x14;
        p_mode->retention_prio = 0x00;
        p_mode->dis_pref_xfer_len = 0xffff;
        p_mode->minimum_prefetch = 0x0000;
        p_mode->max_prefetch = 0x009f;
        p_mode->max_pref_ceiling = 0x027c;
        p_mode->fsw_lbcss_dra = 0x80;
        p_mode->num_cache_segs = 0x03;
        p_mode->cache_seg_size = 0x0000;
        p_mode->reserved = 0x00;
        p_mode->non_cache_seg0 = 0x00;
        p_mode->non_cache_seg1 = 0x00;
        p_mode->non_cache_seg2 = 0x00;
    }
    
    copy_size = MIN(n_bytes, sizeof(scsi_mode_page8_t));
    rtu_MemCopy(p_buf, (uint8*)&local_page, sizeof(scsi_mode_page8_t));

    return copy_size;
}

/**
 * Mode Sense/Select Control Page
 */
uint32 CTarget::load_control_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_pageA_t* p_mode;
    scsi_mode_pageA_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8*)&local_page, sizeof(scsi_mode_pageA_t));

    p_mode->page = 0x0a;
    p_mode->len = 0x0a;
    if((p_cdb[2] & 0xc0) != 0x40){
        p_mode->page = 0x0a;
        p_mode->len = 0x0a;
        p_mode->bits = 0x02;
        p_mode->queue_bits = 0x10;
        p_mode->rac_swp = 0x00;
        p_mode->autoload_mode = 0x00;
        p_mode->unsupp = 0x0000;
        p_mode->busy_timeout = 0x0000;
        p_mode->st_completion_time = 0x00;
    }
    
    copy_size = MIN(n_bytes, sizeof(scsi_mode_pageA_t));
    rtu_MemCopy(p_buf, (uint8*)&local_page, sizeof(scsi_mode_pageA_t));

    return copy_size;
}

uint32 CTarget::load_info_exceptions_page(cbs_buf *p_cbuf, uint8 *p_buf, uint32 n_bytes)
{
    uint32 copy_size;
    scsi_mode_page1C_t *p_mode;
    scsi_mode_page1C_t local_page;
    uint8 *p_cdb;

    p_cdb = p_cbuf->packet.cmd.cdb;

    p_mode = &local_page;

    rtu_MemZero((uint8*)&local_page, sizeof(scsi_mode_page1C));

    p_mode->page = 0x1c;
    p_mode->len = 0x0a;
    if((p_cdb[2] & 0xc0) != 0x40){
        p_mode->bits = 0x00;
        p_mode->mrie = 0x00;
        p_mode->interval_timer = 0x00000000;
        p_mode->report_count = 0x00000000;
    }

    copy_size = MIN(n_bytes, sizeof(scsi_mode_page1C_t));
    rtu_MemCopy(p_buf, (uint8*)&local_page, sizeof(scsi_mode_page1C_t));

    return copy_size;
}
/**************************************end of loadding mode pages****************************/

RT_STATUS CTarget::queue_cbuf(CDevice *p_dev, cbs_buf_t *p_cbuf)
{
    /** 1. check if the device was match   */
    if (p_dev->_index != p_cbuf->device_no)
    {
        LOG_ERROR("cbuf should be add to device:0x%x, "
                  "but send to the wrong device:0x%x", p_cbuf->device_no, p_dev->_index);
        p_cbuf->device_no = p_dev->_index;
    }


    /** 2. add the CBUF to the device queue */
    spin_lock(&p_dev->_q_lock);
    if (p_cbuf->flags & CBUF_FLAG_QUEUE_FIRST)
    {
        /** add to the first of the queue */
        qu_EnQueue(&p_cbuf->links, &p_dev->_cbufs, CBUF_DEVICE_Q);
    } else
    {
        /** add to the back of the queue */
        qu_EnQueueTail(&p_cbuf->links, &p_dev->_cbufs, CBUF_DEVICE_Q);
    }

    p_cbuf->q_sequence = p_dev->_sequence++;
    p_dev->_total_cmd++;
    p_dev->_waitings++
    spin_unlock(&p_dev->_q_lock);

    p_dev->_last_started = time(NULL);
    p_cbuf->queue_time = time(NULL);

    if ((p_cbuf->flags & CBUF_FLAG_SCAN_LATER) != 0) return RT_OK;

    /** 3. scan the device queue */
    target_DeviceScan(p_dev);

    return RT_OK;
}

void CTarget::cmd_done(cbs_buf_t *p_cbuf)
{
    LOG_DEBUG(CBS_DEBUG_LEVEL, CBS_DEBUG_TARGET, "cmd_done in basic class, do nothing.");
}

void CTarget::receive_data(cbs_buf_t *p_cbuf, uint8 *p_data, uint32 size)
{
    LOG_DEBUG(CBS_DEBUG_LEVEL, CBS_DEBUG_TARGET, "receive_data in basic class, do nothing");
}

void CTarget::target_cmd_done(cbs_buf_t *p_cbuf)
{
    if (p_cbuf->packet.response.status != SCSI_STATUS_GOOD)
    {
        build_check_resp_info(p_cbuf);
    } else
    {
        /* check residual if scsi status is good */
        if (p_cbuf->residual != 0)
        {
            p_cbuf->packet.response.status_flags = CBUF_STATUS_FLAG_UNDER;
        }
        p_cbuf->packet.response.residual_count = p_cbuf->residual;
    }

    cmd_done(p_cbuf);

    p_cbuf->target.generic.handle = 0;
    p_cbuf->target.generic.args[0] = 0;

    /* work on target sid finished, call init_IODone */
    //   init_IODone(p_cbuf);

    return;
}

uint32 CTarget::target_extract_sense_info(scsi_sense_info_t& sense_info, uint32 device_no)
{
    scsi_sense_info_t *p_sense_info;

    p_sense_info = get_device_sense(device_no);
    sense_info = *p_sense_info; //copy the latest sense of this device
    if (sense_info.key == 0)
    {
        sense_info.error_code = 0x70;
        return 8;
    }

    return SCSI_SENSE_LEN;
}

void CTarget::reply_good(cbs_buf_t *p_cbuf)
{
    p_cbuf->packet.response.completion_status = 0;
    p_cbuf->packet.response.status = SCSI_STATUS_GOOD;
    p_cbuf->response = CBUF_RESP_COMPLETE;

    cbuf_done(p_cbuf);
}

void CTarget::reply_nodevice(cbs_buf_t *p_cbuf)
{
    p_cbuf->target.gen.sense_context = SENSE_CTX_LUN_UNSUPPORTED;
    p_cbuf->packet.response.status = SCSI_STATUS_CHECK;
    p_cbuf->response = CBUF_RESP_NO_DEVICE;

    cbuf_done(p_cbuf);
}

void CTarget::reply_cmd_aborted(cbs_buf_t *p_cbuf)
{
    /** cbuf has been release, just return. */
    if (p_cbuf->links.flag == CBUF_FREE_Q)
    {
        LOG_ERROR("cbuf[%u, %u] is in free q", p_cbuf->index, p_cbuf->sequence);
        return;
    }

    p_cbuf->target.gen.sense_context = SENSE_CTX_SCSI_PARITY_ERR;
    p_cbuf->packet.response.status = SCSI_STATUS_CHECK;
    p_cbuf->residual = p_cbuf->requested_transfer_size;

    if (p_cbuf->response != CBUF_RESP_TIMEOUT && p_cbuf->response != CBUF_RESP_ABORTED)
    {
        p_cbuf->response = CBUF_RESP_COMPLETE;
    }

    /** Major difference with other target_ReplyXXX function.
     * 1. we want to return CBUF_RESP_TIMEOUT, CBUF_RESP_ABORT or 
     * CBUF_RESP_COMPLETE respectively which tells initiator what 
     * happened when a command aborted by target. Timeout?Or 
     * explicit abort? or other errors. 
     */
    cbuf_done(p_cbuf);

    return;

}

void CTarget::reply_cmd_with_error(cbs_buf_t *p_cbuf, uint32 sense)
{
    BUG_ON(sense == SENSE_CTX_NONE);
    assert(sense < nb_sense_contexts);

    if ((sense == SENSE_CTX_RESET_POWER_ON) || (sense == SENSE_CTX_RESET_DIRECTED))
    {
        target_ReplyGood(p_cbuf);
        return;
    }

    switch (sense)
    {
    case SENSE_CTX_RESERVE_CONF:
        p_cbuf->packet.response.status = SCSI_STATUS_CONFLICT;
        break;
    case SENSE_CTX_TASK_FULL:
        p_cbuf->packet.response.status = SCSI_STATUS_TASK_SET_FULL;
        break;
    default:
        p_cbuf->packet.response.status = SCSI_STATUS_CHECK;
        break;
    }

    p_cbuf->target.gen.sense_context = sense;
    p_cbuf->response = CBUF_RESP_COMPLETE;
    p_cbuf->residual = p_cbuf->requested_transfer_size;

    cbuf_done(p_cbuf);
}

void CTarget::reply_complete(cbs_buf_t *p_cbuf)
{
    p_cbuf->response = CBUF_RESP_COMPLETE;
    cbuf_done(p_cbuf);
}

void CTarget::reply_error(cbs_buf_t *p_cbuf)
{
    p_cbuf->packet.response.status = SCSI_STATUS_CHECK;
    p_cbuf->response = CBUF_RESP_ERROR;
    cbuf_done(p_cbuf);
}

/*-----------------------class targetpool------------------------------------------------*/
void CTargetPool::target_class_init(uint32 class_id, uint32 flags, const char *p_name, CTarget *p_target)
{
    assert(class_id < TARGET_CLASS_MAX);
    assert(G_targets[class_id] == NULL);
    assert(p_name != NULL);

    G_targets[class_id] = p_target;
    p_target->_class_id = class_id;
    p_target->_flags = flags;
    p_target->_name.assign(p_name);

    return;
}

void CTargetPool::init()
{
    CTargetUninit *p_target = new CTargetUninit;
    assert(p_target == NULL);
    target_class_init(TARGET_CLASS_UNINIT, 0, "TARGET_CLASS_UNINIT", p_target);
    return;
}

void CTargetUninit::device_scan(CDevice *p_dev)
{
    LOG_FATAL("device:[%u, %s] is uninit target class", p_dev->get_device_no(), p_dev->_name.c_str());
    assert(false);
    return;
}

void CTargetUninit::cmd_done(cbs_buf_t *p_cbuf)
{
    LOG_FATAL("cbuf queue on a device:%u that is uninit target class", p_cbuf->device_no);
    assert(false);
    return;
}
